<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>droidlet.memory.memory_nodes &mdash; fairo master documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> fairo
          </a>
              <div class="version">
                master
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../controller.html">Controller</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../controller.html#dialogue-manager">Dialogue Manager</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../controller.html#droidlet.dialog.dialogue_manager.DialogueManager"><code class="docutils literal notranslate"><span class="pre">DialogueManager</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../controller.html#droidlet.dialog.dialogue_manager.DialogueManager.step"><code class="docutils literal notranslate"><span class="pre">DialogueManager.step()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../controller.html#semantic-parser">Semantic Parser</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../controller.html#droidlet.perception.semantic_parsing.nsp_transformer_model.query_model.NSPBertModel"><code class="docutils literal notranslate"><span class="pre">NSPBertModel</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../controller.html#dialogue-task">Dialogue Task</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../controller.html#droidlet.dialog.dialogue_task.Say"><code class="docutils literal notranslate"><span class="pre">Say</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../controller.html#droidlet.dialog.dialogue_task.AwaitResponse"><code class="docutils literal notranslate"><span class="pre">AwaitResponse</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../controller.html#droidlet.dialog.dialogue_task.BotCapabilities"><code class="docutils literal notranslate"><span class="pre">BotCapabilities</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../controller.html#droidlet.dialog.dialogue_task.ConfirmTask"><code class="docutils literal notranslate"><span class="pre">ConfirmTask</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../controller.html#interpreter">Interpreter</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../controller.html#droidlet.interpreter.interpreter.Interpreter"><code class="docutils literal notranslate"><span class="pre">Interpreter</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../memory.html">Memory</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../memory.html#database">Database</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory"><code class="docutils literal notranslate"><span class="pre">AgentMemory</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory._db_read"><code class="docutils literal notranslate"><span class="pre">AgentMemory._db_read()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.basic_search"><code class="docutils literal notranslate"><span class="pre">AgentMemory.basic_search()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.forget"><code class="docutils literal notranslate"><span class="pre">AgentMemory.forget()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.get_last_finished_root_task"><code class="docutils literal notranslate"><span class="pre">AgentMemory.get_last_finished_root_task()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.get_mem_by_id"><code class="docutils literal notranslate"><span class="pre">AgentMemory.get_mem_by_id()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.get_recent_entities"><code class="docutils literal notranslate"><span class="pre">AgentMemory.get_recent_entities()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.get_time"><code class="docutils literal notranslate"><span class="pre">AgentMemory.get_time()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.get_world_time"><code class="docutils literal notranslate"><span class="pre">AgentMemory.get_world_time()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.task_stack_clear"><code class="docutils literal notranslate"><span class="pre">AgentMemory.task_stack_clear()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.task_stack_find_lowest_instance"><code class="docutils literal notranslate"><span class="pre">AgentMemory.task_stack_find_lowest_instance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.task_stack_pause"><code class="docutils literal notranslate"><span class="pre">AgentMemory.task_stack_pause()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.task_stack_peek"><code class="docutils literal notranslate"><span class="pre">AgentMemory.task_stack_peek()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.task_stack_pop"><code class="docutils literal notranslate"><span class="pre">AgentMemory.task_stack_pop()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.task_stack_push"><code class="docutils literal notranslate"><span class="pre">AgentMemory.task_stack_push()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.task_stack_resume"><code class="docutils literal notranslate"><span class="pre">AgentMemory.task_stack_resume()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../memory.html#droidlet.memory.sql_memory.AgentMemory.task_stack_update_task"><code class="docutils literal notranslate"><span class="pre">AgentMemory.task_stack_update_task()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../memory.html#memorynodes">MemoryNodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.MemoryNode"><code class="docutils literal notranslate"><span class="pre">MemoryNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.ProgramNode"><code class="docutils literal notranslate"><span class="pre">ProgramNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.NamedAbstractionNode"><code class="docutils literal notranslate"><span class="pre">NamedAbstractionNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.ReferenceObjectNode"><code class="docutils literal notranslate"><span class="pre">ReferenceObjectNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.PlayerNode"><code class="docutils literal notranslate"><span class="pre">PlayerNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.SelfNode"><code class="docutils literal notranslate"><span class="pre">SelfNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.LocationNode"><code class="docutils literal notranslate"><span class="pre">LocationNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.AttentionNode"><code class="docutils literal notranslate"><span class="pre">AttentionNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.TimeNode"><code class="docutils literal notranslate"><span class="pre">TimeNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.ChatNode"><code class="docutils literal notranslate"><span class="pre">ChatNode</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../memory.html#droidlet.memory.memory_nodes.TaskNode"><code class="docutils literal notranslate"><span class="pre">TaskNode</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../perception.html">Perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tasks.html">Tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tasks.html#droidlet.task.task.Task"><code class="docutils literal notranslate"><span class="pre">Task</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../tasks.html#droidlet.task.task.Task.check_finished"><code class="docutils literal notranslate"><span class="pre">Task.check_finished()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tasks.html#droidlet.task.task.Task.interrupt"><code class="docutils literal notranslate"><span class="pre">Task.interrupt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../tasks.html#droidlet.task.task.Task.step"><code class="docutils literal notranslate"><span class="pre">Task.step()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../droidlet_agents.html">Agents</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../droidlet_agents.html#locobot">Locobot</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../droidlet_agents.html#locobot-perception">Locobot Perception</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../droidlet_agents.html#pipelines">Pipelines</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../droidlet_agents.html#components">Components</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../droidlet_agents.html#data-structures">Data Structures</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../droidlet_agents.html#locobot-pyrobot-interface">Locobot PyRobot interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../droidlet_agents.html#craftassist">Craftassist</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../droidlet_agents.html#craftassist-perception">Craftassist Perception</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../droidlet_agents.html#droidlet.perception.craftassist.low_level_perception.LowLevelMCPerception"><code class="docutils literal notranslate"><span class="pre">LowLevelMCPerception</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../droidlet_agents.html#droidlet.perception.craftassist.heuristic_perception.PerceptionWrapper"><code class="docutils literal notranslate"><span class="pre">PerceptionWrapper</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../droidlet_agents.html#droidlet.perception.craftassist.voxel_models.subcomponent_classifier.SubcomponentClassifierWrapper"><code class="docutils literal notranslate"><span class="pre">SubcomponentClassifierWrapper</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">fairo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">droidlet.memory.memory_nodes</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for droidlet.memory.memory_nodes</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Copyright (c) Facebook, Inc. and its affiliates.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">droidlet.base_util</span> <span class="kn">import</span> <span class="n">XYZ</span><span class="p">,</span> <span class="n">POINT_AT_TARGET</span><span class="p">,</span> <span class="n">to_player_struct</span>


<div class="viewcode-block" id="MemoryNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.MemoryNode">[docs]</a><span class="k">class</span> <span class="nc">MemoryNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This is the main class representing a node in the memory</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; MemoryNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">]</span>
    <span class="n">PROPERTIES_BLACKLIST</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;agent_memory&quot;</span><span class="p">,</span> <span class="s2">&quot;forgetme&quot;</span><span class="p">]</span>
    <span class="n">NODE_TYPE</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the Memories table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">()</span><span class="o">.</span><span class="n">hex</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span>
        <span class="n">agent_memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO Memories VALUES (?,?,?,?,?,?)&quot;</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">snapshot</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span> <span class="o">=</span> <span class="n">agent_memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memid</span> <span class="o">=</span> <span class="n">memid</span>

    <span class="k">def</span> <span class="nf">get_tags</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">get_tags_by_memid</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
        <span class="n">blacklist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PROPERTIES_BLACKLIST</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_more_properties_blacklist</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">blacklist</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">update_recently_attended</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">set_memory_attended_time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_more_properties_blacklist</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Override in subclasses to add additional keys to the properties blacklist&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override in subclasses if necessary to properly snapshot.&quot;&quot;&quot;</span>

        <span class="n">read_cmd</span> <span class="o">=</span> <span class="s2">&quot;SELECT &quot;</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TABLE_COLUMNS</span><span class="p">:</span>
            <span class="n">read_cmd</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
        <span class="n">read_cmd</span> <span class="o">=</span> <span class="n">read_cmd</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
        <span class="n">read_cmd</span> <span class="o">+=</span> <span class="s2">&quot; FROM &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">TABLE</span> <span class="o">+</span> <span class="s2">&quot; WHERE uuid=?&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span><span class="n">read_cmd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span><span class="s2">&quot;tried to snapshot nonexistent memory&quot;</span><span class="p">)</span>

        <span class="n">archive_memid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">new_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">archive_memid</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;ARCHIVE_TABLE&quot;</span><span class="p">):</span>
            <span class="n">archive_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ARCHIVE_TABLE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">archive_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">TABLE</span>
        <span class="n">write_cmd</span> <span class="o">=</span> <span class="s2">&quot;INSERT INTO &quot;</span> <span class="o">+</span> <span class="n">archive_table</span> <span class="o">+</span> <span class="s2">&quot;(&quot;</span>
        <span class="n">qs</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TABLE_COLUMNS</span><span class="p">:</span>
            <span class="n">write_cmd</span> <span class="o">+=</span> <span class="n">r</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span>
            <span class="n">qs</span> <span class="o">+=</span> <span class="s2">&quot;?, &quot;</span>
        <span class="n">write_cmd</span> <span class="o">=</span> <span class="n">write_cmd</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
        <span class="n">write_cmd</span> <span class="o">+=</span> <span class="s2">&quot;) VALUES (&quot;</span> <span class="o">+</span> <span class="n">qs</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span>
        <span class="n">agent_memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span><span class="n">write_cmd</span><span class="p">,</span> <span class="o">*</span><span class="n">new_data</span><span class="p">)</span>
        <span class="n">link_archive_to_mem</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">,</span> <span class="n">archive_memid</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">link_archive_to_mem</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="n">archive_memid</span><span class="p">):</span>
    <span class="n">agent_memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
        <span class="n">agent_memory</span><span class="p">,</span> <span class="n">subj</span><span class="o">=</span><span class="n">archive_memid</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;_archive_of&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="n">memid</span>
    <span class="p">)</span>
    <span class="n">agent_memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
        <span class="n">agent_memory</span><span class="p">,</span> <span class="n">subj</span><span class="o">=</span><span class="n">memid</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;_has_archive&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="n">archive_memid</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">dehydrate</span><span class="p">(</span><span class="n">lf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    replace any MemoryNode m in a logical form with {&quot;dehydrated_mem&quot;: m.memid}</span>
<span class="sd">    This is used to store a logical form in the db; as logical forms may contain</span>
<span class="sd">    MemoryNodes as values, this makes it easier to serialize (text instead of python object).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lf</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">MemoryNode</span><span class="p">):</span>
            <span class="n">lf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dehydrated_mem&quot;</span><span class="p">:</span> <span class="n">v</span><span class="o">.</span><span class="n">memid</span><span class="p">}</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">dehydrate</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="n">dehydrate</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>


<div class="viewcode-block" id="ProgramNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.ProgramNode">[docs]</a><span class="k">class</span> <span class="nc">ProgramNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents the logical forms (outputs from</span>
<span class="sd">    the semantic parser)</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        logical_form (dict): The semantic parser output for text</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; ProgramNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;logical_form&quot;</span><span class="p">]</span>
    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;Programs&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Program&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT logical_form FROM Programs WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lf</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rehydrate</span><span class="p">(</span><span class="n">lf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logical_form</span> <span class="o">=</span> <span class="n">lf</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">logical_form</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the Programs table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; memory = AgentMemory()</span>
<span class="sd">            &gt;&gt;&gt; logical_form = {&quot;dialogue_type&quot; : &quot;HUMAN_GIVE_COMMAND&quot;,</span>
<span class="sd">                                &quot;action_sequence&quot; : [</span>
<span class="sd">                                    {</span>
<span class="sd">                                        &quot;action_type&quot;: &quot;BUILD&quot;,</span>
<span class="sd">                                        &quot;schematic&quot;: {&quot;has_name&quot;: &quot;sphere&quot;},</span>
<span class="sd">                                    }]}</span>
<span class="sd">            &gt;&gt;&gt; create(memory, logical_form)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="n">snapshot</span><span class="p">)</span>
        <span class="n">dehydrate</span><span class="p">(</span><span class="n">logical_form</span><span class="p">)</span>
        <span class="n">logical_form_text</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">logical_form</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO Programs(uuid, logical_form) VALUES (?,?)&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
            <span class="nb">format</span><span class="p">(</span><span class="n">logical_form_text</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="k">def</span> <span class="nf">rehydrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        replace any {&quot;dehydrated_mem&quot;: m.memid} with the associated MemoryNode</span>
<span class="sd">        This is used when retrieving a logical form in the db; as logical forms may contain</span>
<span class="sd">        MemoryNodes as values, this makes it easier to serialize (text instead of python object).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">lf</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">memid</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dehydrated_mem&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">memid</span><span class="p">:</span>
                    <span class="n">lf</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">get_mem_by_id</span><span class="p">(</span><span class="n">memid</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rehydrate</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rehydrate</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>


<span class="c1"># TODO FIXME instantiate as a side effect of making triples</span>
<div class="viewcode-block" id="NamedAbstractionNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.NamedAbstractionNode">[docs]</a><span class="k">class</span> <span class="nc">NamedAbstractionNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents an abstract concept with a name,</span>
<span class="sd">    to be used in triples</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        name (string): Name of the abstraction, for example : &quot;has_tag&quot;</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; NamedAbstractionNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">]</span>
    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;NamedAbstractions&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;NamedAbstraction&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT name FROM NamedAbstractions WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the NamedAbstractions table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; memory = AgentMemory()</span>
<span class="sd">            &gt;&gt;&gt; name = &quot;has_tag&quot;</span>
<span class="sd">            &gt;&gt;&gt; create(memory, name)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span><span class="s2">&quot;SELECT uuid FROM NamedAbstractions WHERE name=?&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">memid</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">memid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="n">snapshot</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span><span class="s2">&quot;INSERT INTO NamedAbstractions(uuid, name) VALUES (?,?)&quot;</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span></div>


<span class="k">class</span> <span class="nc">TripleNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents a (subject, predicate, object) KB triple</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        subj_text (string): the text of the subject</span>
<span class="sd">        subj (string):      the memid of the subject</span>
<span class="sd">        pred_text (string): the text of the predicate</span>
<span class="sd">        pred (string):      the memid of the predicate (a NamedAbstraction)</span>
<span class="sd">        obj_text (string):  the text of the object</span>
<span class="sd">        obj (string):       the memid of the object</span>
<span class="sd">        confidence (float): float between 0 and 1, currently unused</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;uuid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;subj&quot;</span><span class="p">,</span>
        <span class="s2">&quot;subj_text&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pred&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pred_text&quot;</span><span class="p">,</span>
        <span class="s2">&quot;obj&quot;</span><span class="p">,</span>
        <span class="s2">&quot;obj_text&quot;</span><span class="p">,</span>
        <span class="s2">&quot;confidence&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;Triples&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Triple&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">triple</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT subj_text, subj, pred_text, pred, obj_text, obj, confidence FROM Triples WHERE uuid=?&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">memory</span><span class="p">,</span>
        <span class="n">snapshot</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">subj</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># this is a memid if given</span>
        <span class="n">obj</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># this is a memid if given</span>
        <span class="n">subj_text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pred_text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;has_tag&quot;</span><span class="p">,</span>
        <span class="n">obj_text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">confidence</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds (subj, pred, obj) triple to the triplestore.</span>
<span class="sd">            *_text is the name field of a NamedAbstraction; if</span>
<span class="sd">            such a NamedAbstraction does not exist, this builds it as a side effect.</span>
<span class="sd">            subj and obj can be memids or text, but pred_text is required</span>

<span class="sd">        Args:</span>
<span class="sd">            subj (string): memid of subject</span>
<span class="sd">            obj (string): memid of object</span>
<span class="sd">            subj_text (string): text representation for subject</span>
<span class="sd">            pred_text (string): predicate text</span>
<span class="sd">            obj_text (string): text representation for object</span>
<span class="sd">            confidence (float): The confidence score for the triple</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: memid of triple</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">subj</span> <span class="ow">or</span> <span class="n">subj_text</span>
        <span class="k">assert</span> <span class="n">obj</span> <span class="ow">or</span> <span class="n">obj_text</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">subj</span> <span class="ow">and</span> <span class="n">subj_text</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">obj</span> <span class="ow">and</span> <span class="n">obj_text</span><span class="p">)</span>
        <span class="n">pred</span> <span class="o">=</span> <span class="n">NamedAbstractionNode</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">pred_text</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">NamedAbstractionNode</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">obj_text</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">subj</span><span class="p">:</span>
            <span class="n">subj</span> <span class="o">=</span> <span class="n">NamedAbstractionNode</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">subj_text</span><span class="p">)</span>
        <span class="c1"># check if triple exists, don&#39;t make it again:</span>
        <span class="n">old_memids</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">_db_read</span><span class="p">(</span>
            <span class="s2">&quot;SELECT uuid FROM Triples where pred=? and subj=? and obj=?&quot;</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">subj</span><span class="p">,</span> <span class="n">obj</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_memids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># TODO error if more than 1</span>
            <span class="k">return</span> <span class="n">old_memids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="n">snapshot</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO Triples VALUES (?, ?, ?, ?, ?, ?, ?, ?)&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
            <span class="n">subj</span><span class="p">,</span>
            <span class="n">subj_text</span><span class="p">,</span>
            <span class="n">pred</span><span class="p">,</span>
            <span class="n">pred_text</span><span class="p">,</span>
            <span class="n">obj</span><span class="p">,</span>
            <span class="n">obj_text</span><span class="p">,</span>
            <span class="n">confidence</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="c1"># does not search archived mems for now</span>
    <span class="c1"># TODO clean up input?</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_triples</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">agent_memory</span><span class="p">,</span>
        <span class="n">subj</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">subj_text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pred_text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">obj_text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">return_obj_text</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;if_exists&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;gets triples from the triplestore.</span>
<span class="sd">        subj is always returned as a memid even when searched as text.</span>
<span class="sd">        need at least one non-None part of the triple, and</span>
<span class="sd">        text should not not be input for a part of a triple where a memid is set.</span>

<span class="sd">        Args:</span>
<span class="sd">            subj (string): memid of subject</span>
<span class="sd">            obj (string): memid of object</span>
<span class="sd">            subj_text (string): text of the subject (if applicable, as opposed to subject memid)</span>
<span class="sd">            pred_text (string): text of the predicate</span>
<span class="sd">            obj_text (string): text of the subject (if applicable, as opposed to subject memid)</span>
<span class="sd">            return_obj_text (string): if return_obj_text == &quot;if_exists&quot;, will return the obj_text</span>
<span class="sd">                             if it exists, and the memid otherwise. If return_obj_text</span>
<span class="sd">                             == &quot;always&quot;, returns the obj_text even if it is None. If</span>
<span class="sd">                             return_obj_text == &quot;never&quot;, returns the obj memid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[tuple]: A list of tuples of the form : (subject, predicate, object)</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; subj = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">            &gt;&gt;&gt; obj_text = &#39;blue&#39;</span>
<span class="sd">            &gt;&gt;&gt; pred_text = &quot;has_colour&quot;</span>
<span class="sd">            &gt;&gt;&gt; get_triples(agent_memory,</span>
<span class="sd">                            subj=subj,</span>
<span class="sd">                            pred_text=pred_text,</span>
<span class="sd">                            obj_text=obj_text)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">any</span><span class="p">([</span><span class="n">subj</span> <span class="ow">or</span> <span class="n">subj_text</span><span class="p">,</span> <span class="n">pred_text</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">or</span> <span class="n">obj_text</span><span class="p">])</span>
        <span class="c1"># search by memid or by text, but not both</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">subj</span> <span class="ow">and</span> <span class="n">subj_text</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">obj</span> <span class="ow">and</span> <span class="n">obj_text</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;subj&quot;</span><span class="p">,</span> <span class="n">subj</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;subj_text&quot;</span><span class="p">,</span> <span class="n">subj_text</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;pred_text&quot;</span><span class="p">,</span> <span class="n">pred_text</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;obj&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;obj_text&quot;</span><span class="p">,</span> <span class="n">obj_text</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">where</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;=?&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">where</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">where_clause</span> <span class="o">=</span> <span class="n">where</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">where_clause</span> <span class="o">=</span> <span class="s2">&quot; AND &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">where</span><span class="p">)</span>
        <span class="n">return_clause</span> <span class="o">=</span> <span class="s2">&quot;subj, pred_text, obj, obj_text &quot;</span>
        <span class="n">sql</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;SELECT &quot;</span>
            <span class="o">+</span> <span class="n">return_clause</span>
            <span class="o">+</span> <span class="s2">&quot;FROM Triples INNER JOIN Memories as M ON Triples.subj=M.uuid WHERE M.is_snapshot=0 AND &quot;</span>
            <span class="o">+</span> <span class="n">where_clause</span>
        <span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read</span><span class="p">(</span><span class="n">sql</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># subj is always returned as memid, even if pred and obj are returned as text</span>
        <span class="c1"># pred is always returned as text</span>
        <span class="k">if</span> <span class="n">return_obj_text</span> <span class="o">==</span> <span class="s2">&quot;if_exists&quot;</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ot</span><span class="p">)</span> <span class="k">if</span> <span class="n">ot</span> <span class="k">else</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">ot</span><span class="p">)</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">return_obj_text</span> <span class="o">==</span> <span class="s2">&quot;always&quot;</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">ot</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">ot</span><span class="p">)</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">ot</span><span class="p">)</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">l</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">subj_memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">tag_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Tag the subject with tag text.</span>

<span class="sd">        Args:</span>
<span class="sd">            subj_memid (string): memid of subject</span>
<span class="sd">            tag_text (string): string representation of the tag</span>

<span class="sd">        Returns:</span>
<span class="sd">            memid of triple representing the tag</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; subj_memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">            &gt;&gt;&gt; tag_text = &quot;shiny&quot;</span>
<span class="sd">            &gt;&gt;&gt; tag(agent_memory, subj_memid, tag_text)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">agent_memory</span><span class="p">,</span> <span class="n">subj</span><span class="o">=</span><span class="n">subj_memid</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;has_tag&quot;</span><span class="p">,</span> <span class="n">obj_text</span><span class="o">=</span><span class="n">tag_text</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_tags_by_memid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">subj_memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">return_text</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Find all tag for a given memid</span>

<span class="sd">        Args:</span>
<span class="sd">            subj_memid (string): the subject&#39;s memid (uuid from Memories table)</span>
<span class="sd">            return_text (bool): if true, return the object text, otherwise return object memid</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[string]: list of tags.</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; subj_memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">            &gt;&gt;&gt; get_tags_by_memid(agent_memory, subj_memid=subj_memid, return_text=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">return_text</span><span class="p">:</span>
            <span class="n">return_clause</span> <span class="o">=</span> <span class="s2">&quot;obj_text&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">return_clause</span> <span class="o">=</span> <span class="s2">&quot;obj&quot;</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;SELECT DISTINCT(&quot;</span>
            <span class="o">+</span> <span class="n">return_clause</span>
            <span class="o">+</span> <span class="s1">&#39;) FROM Triples WHERE pred_text=&quot;has_tag&quot; AND subj=?&#39;</span>
        <span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">subj_memid</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>

    <span class="c1"># does not search archived mems for now</span>
    <span class="c1"># assumes tag is tag text</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_memids_by_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Find all memids with a given tag</span>

<span class="sd">        Args:</span>
<span class="sd">            tag (string): string representation of the tag</span>

<span class="sd">        Returns:</span>
<span class="sd">            list[string]: list of memory ids (which are strings)</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; tag = &quot;round&quot;</span>
<span class="sd">            &gt;&gt;&gt; get_memids_by_tag(agent_memory, tag)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read</span><span class="p">(</span>
            <span class="s1">&#39;SELECT DISTINCT(Memories.uuid) FROM Memories INNER JOIN Triples as T ON T.subj=Memories.uuid WHERE T.pred_text=&quot;has_tag&quot; AND T.obj_text=? AND Memories.is_snapshot=0&#39;</span><span class="p">,</span>
            <span class="n">tag</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,)</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>

    <span class="nd">@classmethod</span>
    <span class="c1"># TODO remove_triple</span>
    <span class="k">def</span> <span class="nf">untag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">subj_memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">tag_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Delete tag for subject</span>

<span class="sd">        Args:</span>
<span class="sd">            subj_memid (string): memid of subject</span>
<span class="sd">            tag_text (string): string representation of the tag</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; subj_memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">            &gt;&gt;&gt; tag_text = &quot;shiny&quot;</span>
<span class="sd">            &gt;&gt;&gt; untag(agent_memory, subj_memid, tag_text)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># FIXME replace me with a basic filters when _self handled better</span>
        <span class="n">triple_memids</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read</span><span class="p">(</span>
            <span class="s1">&#39;SELECT uuid FROM Triples WHERE subj=? AND pred_text=&quot;has_tag&quot; AND obj_text=?&#39;</span><span class="p">,</span>
            <span class="n">subj_memid</span><span class="p">,</span>
            <span class="n">tag_text</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">triple_memids</span><span class="p">:</span>
            <span class="n">agent_memory</span><span class="o">.</span><span class="n">forget</span><span class="p">(</span><span class="n">triple_memids</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">InterpreterNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;for representing interpreter objects&quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">]</span>
    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;InterpreterMems&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Interpreter&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="n">finished</span><span class="p">,</span> <span class="n">awaiting_response</span><span class="p">,</span> <span class="n">interpreter_type</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT finished, awaiting_response, interpreter_type FROM InterpreterMems where uuid=?&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">finished</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">awaiting_response</span> <span class="o">=</span> <span class="n">awaiting_response</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interpreter_type</span> <span class="o">=</span> <span class="n">interpreter_type</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">memory</span><span class="p">,</span>
        <span class="n">interpreter_type</span><span class="o">=</span><span class="s2">&quot;interpeter&quot;</span><span class="p">,</span>
        <span class="n">finished</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">awaiting_response</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">snapshot</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="n">snapshot</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO InterpreterMems(uuid, finished, awaiting_response, interpreter_type) VALUES (?,?,?,?)&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
            <span class="n">finished</span><span class="p">,</span>
            <span class="n">awaiting_response</span><span class="p">,</span>
            <span class="n">interpreter_type</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;UPDATE InterpreterMems SET finished=? WHERE uuid=?&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>


<span class="c1"># the table entry just has the memid and a modification time,</span>
<span class="c1"># actual set elements are handled as triples</span>
<span class="k">class</span> <span class="nc">SetNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;for representing sets of objects, so that it is easier to build complex relations</span>
<span class="sd">    using RDF/triplestore format.&quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">]</span>
    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;SetMems&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Set&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>

    <span class="c1"># FIXME put the member triples</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="n">snapshot</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span><span class="s2">&quot;INSERT INTO SetMems(uuid) VALUES (?)&quot;</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="k">def</span> <span class="nf">get_members</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">get_triples</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;member_of&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">SetNode</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">snapshot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="ReferenceObjectNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.ReferenceObjectNode">[docs]</a><span class="k">class</span> <span class="nc">ReferenceObjectNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a class representing generic memory node for anything that has a spatial location and can be</span>
<span class="sd">    used a spatial reference (e.g. to the left of the x).</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode, ReferenceObjectNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; ReferenceObjectNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;ReferenceObjects&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;ReferenceObject&quot;</span>
    <span class="n">ARCHIVE_TABLE</span> <span class="o">=</span> <span class="s2">&quot;ArchivedReferenceObjects&quot;</span>

    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">XYZ</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must be implemented in subclass&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_point_at_target</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">POINT_AT_TARGET</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must be implemented in subclass&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;must be implemented in subclass&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PlayerNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.PlayerNode">[docs]</a><span class="k">class</span> <span class="nc">PlayerNode</span><span class="p">(</span><span class="n">ReferenceObjectNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents humans and other agents that can affect</span>
<span class="sd">    the world</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        eid (int): Entity ID</span>
<span class="sd">        name (string): Name of player</span>
<span class="sd">        pos (tuple(float, float, float)): x, y, z coordinates</span>
<span class="sd">        pitch (float): the vertical angle of the agent&#39;s view vector</span>
<span class="sd">        yaw (float): the horizontal rotation angle of the agent&#39;s view vector</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode, PlayerNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; PlayerNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;eid&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;pitch&quot;</span><span class="p">,</span> <span class="s2">&quot;yaw&quot;</span><span class="p">,</span> <span class="s2">&quot;ref_type&quot;</span><span class="p">]</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Player&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="n">eid</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT eid, name, x, y, z, pitch, yaw FROM ReferenceObjects WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eid</span> <span class="o">=</span> <span class="n">eid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pitch</span> <span class="o">=</span> <span class="n">pitch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaw</span> <span class="o">=</span> <span class="n">yaw</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">player_struct</span><span class="p">,</span> <span class="n">memid</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the ReferenceObjects table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; memory = AgentMemory()</span>
<span class="sd">            &gt;&gt;&gt; from collections import namedtuple</span>
<span class="sd">            &gt;&gt;&gt; Player = namedtuple(&quot;Player&quot;, &quot;entityId, name, pos, look, mainHand&quot;)</span>
<span class="sd">            &gt;&gt;&gt; player_struct = Player(</span>
<span class="sd">                12345678, &quot;dashboard&quot;, Pos(0.0, 0.0, 0.0), Look(0.0, 0.0), Item(0, 0)</span>
<span class="sd">            )</span>
<span class="sd">            &gt;&gt;&gt; create(memory, player_struct)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="n">memid</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>

        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO ReferenceObjects(uuid, eid, name, x, y, z, pitch, yaw, ref_type) VALUES (?,?,?,?,?,?,?,?,?)&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
            <span class="n">player_struct</span><span class="o">.</span><span class="n">entityId</span><span class="p">,</span>
            <span class="n">player_struct</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">player_struct</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">x</span><span class="p">,</span>
            <span class="n">player_struct</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
            <span class="n">player_struct</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
            <span class="n">player_struct</span><span class="o">.</span><span class="n">look</span><span class="o">.</span><span class="n">pitch</span><span class="p">,</span>
            <span class="n">player_struct</span><span class="o">.</span><span class="n">look</span><span class="o">.</span><span class="n">yaw</span><span class="p">,</span>
            <span class="s2">&quot;player&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;_player&quot;</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;_physical_object&quot;</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;_animate&quot;</span><span class="p">)</span>
        <span class="c1"># this is a hack until memory_filters does &quot;not&quot;</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;_not_location&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">player_struct</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
                <span class="n">memory</span><span class="p">,</span> <span class="n">subj</span><span class="o">=</span><span class="n">memid</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;has_name&quot;</span><span class="p">,</span> <span class="n">obj_text</span><span class="o">=</span><span class="n">player_struct</span><span class="o">.</span><span class="n">name</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;UPDATE ReferenceObjects SET eid=?, name=?, x=?,  y=?, z=?, pitch=?, yaw=? WHERE &quot;</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">cmd</span> <span class="o">+</span> <span class="s2">&quot;uuid=?&quot;</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="n">cmd</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">entityId</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">pos</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">look</span><span class="o">.</span><span class="n">pitch</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">look</span><span class="o">.</span><span class="n">yaw</span><span class="p">,</span> <span class="n">memid</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">XYZ</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT x, y, z FROM ReferenceObjects WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>

    <span class="k">def</span> <span class="nf">get_yaw_pitch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">yaw</span><span class="p">,</span> <span class="n">pitch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT yaw, pitch FROM ReferenceObjects WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaw</span> <span class="o">=</span> <span class="n">yaw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pitch</span> <span class="o">=</span> <span class="n">pitch</span>
        <span class="k">return</span> <span class="n">yaw</span><span class="p">,</span> <span class="n">pitch</span>

    <span class="c1"># TODO: use a smarter way to get point_at_target</span>
    <span class="k">def</span> <span class="nf">get_point_at_target</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">POINT_AT_TARGET</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="c1"># use the block above the player as point_at_target</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">POINT_AT_TARGET</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span>

    <span class="k">def</span> <span class="nf">get_struct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">to_player_struct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pitch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">eid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1"># TODO consolidate anything using eid</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_player_by_eid</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">eid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;PlayerNode&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Given eid, retrieve PlayerNode</span>

<span class="sd">        Args:</span>
<span class="sd">            eid (int): Entity ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span><span class="s2">&quot;SELECT uuid FROM ReferenceObjects WHERE eid=?&quot;</span><span class="p">,</span> <span class="n">eid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PlayerNode</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="SelfNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.SelfNode">[docs]</a><span class="k">class</span> <span class="nc">SelfNode</span><span class="p">(</span><span class="n">PlayerNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class is a special PlayerNode for representing the</span>
<span class="sd">    agent&#39;s self</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory  (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode, PlayerNode, SelfNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; SelfNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;eid&quot;</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;pitch&quot;</span><span class="p">,</span> <span class="s2">&quot;yaw&quot;</span><span class="p">,</span> <span class="s2">&quot;ref_type&quot;</span><span class="p">]</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Self&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">player_struct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">memid</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the ReferenceObjects table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="n">memid</span> <span class="ow">or</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">player_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">eid</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eid</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="n">player_struct</span><span class="o">.</span><span class="n">entityId</span><span class="p">,</span> <span class="n">player_struct</span><span class="o">.</span><span class="n">name</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">player_struct</span><span class="o">.</span><span class="n">pos</span>
            <span class="n">yaw</span><span class="p">,</span> <span class="n">pitch</span> <span class="o">=</span> <span class="n">player_struct</span><span class="o">.</span><span class="n">look</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;INSERT INTO ReferenceObjects(uuid, eid, name, x, y, z, pitch, yaw, ref_type) VALUES (?,?,?,?,?,?,?,?,?)&quot;</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="n">eid</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">,</span> <span class="s2">&quot;self&quot;</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;AGENT&quot;</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;SELF&quot;</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;_physical_object&quot;</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;_animate&quot;</span><span class="p">)</span>
        <span class="c1"># this is a hack until memory_filters does &quot;not&quot;</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">tag</span><span class="p">(</span><span class="n">memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="s2">&quot;_not_location&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
                <span class="n">memory</span><span class="p">,</span> <span class="n">subj</span><span class="o">=</span><span class="n">memid</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;has_name&quot;</span><span class="p">,</span> <span class="n">obj_text</span><span class="o">=</span><span class="n">player_struct</span><span class="o">.</span><span class="n">name</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span></div>


<span class="c1"># locations should always be archives?</span>
<div class="viewcode-block" id="LocationNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.LocationNode">[docs]</a><span class="k">class</span> <span class="nc">LocationNode</span><span class="p">(</span><span class="n">ReferenceObjectNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a ReferenceObjectNode representing a raw location</span>
<span class="sd">    (a point in space)</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        location (tuple): (x, y, z) coordinates of the node</span>
<span class="sd">        pos (tuple): (x, y, z) coordinates of the node</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode, LocationNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; LocationNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;ref_type&quot;</span><span class="p">]</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Location&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT x, y, z FROM ReferenceObjects WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">xyz</span><span class="p">:</span> <span class="n">XYZ</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the ReferenceObjects table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; memory = AgentMemory()</span>
<span class="sd">            &gt;&gt;&gt; xyz = [0.0, 1.0, 3.0]</span>
<span class="sd">            &gt;&gt;&gt; create(memory, xyz)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO ReferenceObjects(uuid, x, y, z, ref_type) VALUES (?, ?, ?, ?, ?)&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
            <span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s2">&quot;location&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="k">def</span> <span class="nf">get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">z</span>

    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">XYZ</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>

    <span class="k">def</span> <span class="nf">get_point_at_target</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">POINT_AT_TARGET</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">POINT_AT_TARGET</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span></div>


<span class="c1"># locations should always be archives?</span>
<div class="viewcode-block" id="AttentionNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.AttentionNode">[docs]</a><span class="k">class</span> <span class="nc">AttentionNode</span><span class="p">(</span><span class="n">LocationNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a ReferenceObjectNode representing spatial attention</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        attended (string): name of the node that is attending</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode, AttentionNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; AttentionNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;type_name&quot;</span><span class="p">,</span> <span class="s2">&quot;ref_type&quot;</span><span class="p">]</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Attention&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="c1"># we use the type_name field to store whose attention it is</span>
        <span class="n">attender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT type_name FROM ReferenceObjects WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attender</span> <span class="o">=</span> <span class="n">attender</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">xyz</span><span class="p">:</span> <span class="n">XYZ</span><span class="p">,</span> <span class="n">attender</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the ReferenceObjects table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; memory = AgentMemory()</span>
<span class="sd">            &gt;&gt;&gt; xyz = [0.0, 2.0, 50.0]</span>
<span class="sd">            &gt;&gt;&gt; attender = 12345678 # entity ID of player</span>
<span class="sd">            &gt;&gt;&gt; create(memory, xyz, attender)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO ReferenceObjects(uuid, x, y, z, type_name, ref_type) VALUES (?, ?, ?, ?, ?, ?)&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
            <span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">xyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">xyz</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">attender</span><span class="p">,</span>
            <span class="s2">&quot;attention&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span></div>


<div class="viewcode-block" id="TimeNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.TimeNode">[docs]</a><span class="k">class</span> <span class="nc">TimeNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class represents a temporal &#39;location&#39;</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        time (int): the value of time</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode, TimeNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; TimeNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]</span>
    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;Times&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Time&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span><span class="s2">&quot;SELECT time FROM Times WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">t</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the Times table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; memory = AgentMemory()</span>
<span class="sd">            &gt;&gt;&gt; time = 1234</span>
<span class="sd">            &gt;&gt;&gt; create(memory, time)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span><span class="s2">&quot;INSERT INTO Times(uuid, time) VALUES (?, ?)&quot;</span><span class="p">,</span> <span class="n">memid</span><span class="p">,</span> <span class="n">time</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span></div>


<div class="viewcode-block" id="ChatNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.ChatNode">[docs]</a><span class="k">class</span> <span class="nc">ChatNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This node represents a chat/utterance from another agent/human</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        speaker_id (string): The memid of the speaker who sent the chat</span>
<span class="sd">        chat_text (string): The chat string</span>
<span class="sd">        time (int): The time at which the chat was delivered</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode, ChatNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; ChatNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;uuid&quot;</span><span class="p">,</span> <span class="s2">&quot;speaker&quot;</span><span class="p">,</span> <span class="s2">&quot;chat&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]</span>
    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;Chats&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Chat&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="n">speaker</span><span class="p">,</span> <span class="n">chat_text</span><span class="p">,</span> <span class="n">time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT speaker, chat, time FROM Chats WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speaker_id</span> <span class="o">=</span> <span class="n">speaker</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chat_text</span> <span class="o">=</span> <span class="n">chat_text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">speaker</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">chat</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the Chats table</span>

<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; memory = AgentMemory()</span>
<span class="sd">            &gt;&gt;&gt; speaker = &quot;189fsfagf9382jfjash&quot; #&#39;name&#39; of the Player giving the command</span>
<span class="sd">            &gt;&gt;&gt; chat = &quot;come here&quot;</span>
<span class="sd">            &gt;&gt;&gt; create(memory, speaker, chat)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO Chats(uuid, speaker, chat, time) VALUES (?, ?, ?, ?)&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
            <span class="n">speaker</span><span class="p">,</span>
            <span class="n">chat</span><span class="p">,</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">get_time</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_most_recent_incoming_chat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">after</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;ChatNode&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the most recent chat that came in since &#39;after&#39;</span>

<span class="sd">        Args:</span>
<span class="sd">            after (int): Marks the beginning of time window (from now)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SELECT uuid</span>
<span class="sd">            FROM Chats</span>
<span class="sd">            WHERE speaker != ? AND time &gt;= ?</span>
<span class="sd">            ORDER BY time DESC</span>
<span class="sd">            LIMIT 1</span>
<span class="sd">            &quot;&quot;&quot;</span><span class="p">,</span>
            <span class="n">agent_memory</span><span class="o">.</span><span class="n">self_memid</span><span class="p">,</span>
            <span class="n">after</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ChatNode</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">get_recent_chats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ChatNode&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of at most n chats</span>

<span class="sd">        Args:</span>
<span class="sd">            n (int): number of recent chats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read</span><span class="p">(</span><span class="s2">&quot;SELECT uuid FROM Chats ORDER BY time DESC LIMIT ?&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">ChatNode</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span></div>


<div class="viewcode-block" id="TaskNode"><a class="viewcode-back" href="../../../memory.html#droidlet.memory.memory_nodes.TaskNode">[docs]</a><span class="k">class</span> <span class="nc">TaskNode</span><span class="p">(</span><span class="n">MemoryNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This node represents a task object that was placed on</span>
<span class="sd">    the agent&#39;s task_stack</span>

<span class="sd">    Args:</span>
<span class="sd">        agent_memory (AgentMemory): An AgentMemory object</span>
<span class="sd">        memid (string): Memory ID for this node</span>

<span class="sd">    Attributes:</span>
<span class="sd">        task (object): Name of the task</span>
<span class="sd">        created (int): Time at which it was created</span>
<span class="sd">        finished (int): Time at which it was finished</span>
<span class="sd">        action_name (string): The name of action that corresponds to this task</span>

<span class="sd">    Examples::</span>
<span class="sd">        &gt;&gt;&gt; node_list = [TaskNode]</span>
<span class="sd">        &gt;&gt;&gt; schema_path = [os.path.join(os.path.dirname(__file__), &quot;memory_schema.sql&quot;)]</span>
<span class="sd">        &gt;&gt;&gt; agent_memory = AgentMemory(db_file=&quot;:memory:&quot;,</span>
<span class="sd">                                       schema_paths=schema_path,</span>
<span class="sd">                                       db_log_path=None,</span>
<span class="sd">                                       nodelist=node_list)</span>
<span class="sd">        &gt;&gt;&gt; memid = &#39;10517cc584844659907ccfa6161e9d32&#39;</span>
<span class="sd">        &gt;&gt;&gt; TaskNode(agent_memory=agent_memory, memid=memid)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">TABLE_COLUMNS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;uuid&quot;</span><span class="p">,</span>
        <span class="s2">&quot;action_name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;pickled&quot;</span><span class="p">,</span>
        <span class="s2">&quot;prio&quot;</span><span class="p">,</span>
        <span class="s2">&quot;running&quot;</span><span class="p">,</span>
        <span class="s2">&quot;run_count&quot;</span><span class="p">,</span>
        <span class="s2">&quot;paused&quot;</span><span class="p">,</span>
        <span class="s2">&quot;created&quot;</span><span class="p">,</span>
        <span class="s2">&quot;finished&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">TABLE</span> <span class="o">=</span> <span class="s2">&quot;Tasks&quot;</span>
    <span class="n">NODE_TYPE</span> <span class="o">=</span> <span class="s2">&quot;Task&quot;</span>
    <span class="n">EGG_PRIO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span>
    <span class="n">CHECK_PRIO</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">FINISHED_PRIO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">memid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_node</span><span class="p">()</span>
        <span class="n">pickled</span><span class="p">,</span> <span class="n">created</span><span class="p">,</span> <span class="n">action_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT pickled, created, action_name FROM Tasks WHERE uuid=?&quot;</span><span class="p">,</span> <span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">safe_unpickle</span><span class="p">(</span><span class="n">pickled</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">created</span> <span class="o">=</span> <span class="n">created</span>
        <span class="c1"># TODO changeme to just &quot;name&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">action_name</span> <span class="o">=</span> <span class="n">action_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">agent_memory</span>

    <span class="k">def</span> <span class="nf">update_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">prio</span><span class="p">,</span> <span class="n">running</span><span class="p">,</span> <span class="n">run_count</span><span class="p">,</span> <span class="n">finished</span><span class="p">,</span> <span class="n">paused</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">_db_read_one</span><span class="p">(</span>
            <span class="s2">&quot;SELECT prio, running, run_count, finished, paused FROM Tasks WHERE uuid=?&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prio</span> <span class="o">=</span> <span class="n">prio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paused</span> <span class="o">=</span> <span class="n">paused</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_count</span> <span class="o">=</span> <span class="n">run_count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">running</span> <span class="o">=</span> <span class="n">running</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finished</span> <span class="o">=</span> <span class="n">finished</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">create</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates a new entry into the Tasks table</span>

<span class="sd">        the input task can be an instantiated Task</span>
<span class="sd">            or a dict with followng structure:</span>
<span class="sd">            {&quot;class&quot;: TaskClass,</span>
<span class="sd">             &quot;task_data&quot;: {...}}</span>
<span class="sd">            in this case, the TaskClass is the uninstantiated class</span>
<span class="sd">            and the agent will run update_task() when it is instantiated</span>


<span class="sd">        Returns:</span>
<span class="sd">            string: memid of the entry</span>

<span class="sd">        Examples::</span>
<span class="sd">            &gt;&gt;&gt; memory = AgentMemory()</span>
<span class="sd">            &gt;&gt;&gt; task = Task()</span>
<span class="sd">            &gt;&gt;&gt; create(memory, task)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old_memid</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="s2">&quot;memid&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old_memid</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">old_memid</span>
        <span class="n">memid</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">memory</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="c1"># this is an egg to be hatched by agent</span>
            <span class="n">prio</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;task_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task_node_data&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;prio&quot;</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="n">EGG_PRIO</span><span class="p">)</span>
            <span class="n">running</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;task_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task_node_data&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;running&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">run_count</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;task_data&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;task_node_data&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;run_count&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">action_name</span> <span class="o">=</span> <span class="n">task</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">action_name</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">prio</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">CHECK_PRIO</span>
            <span class="n">running</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">run_count</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">run_count</span>
            <span class="n">task</span><span class="o">.</span><span class="n">memid</span> <span class="o">=</span> <span class="n">memid</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">_db_write</span><span class="p">(</span>
            <span class="s2">&quot;INSERT INTO Tasks (uuid, action_name, pickled, prio, running, run_count, created) VALUES (?,?,?,?,?,?,?)&quot;</span><span class="p">,</span>
            <span class="n">memid</span><span class="p">,</span>
            <span class="n">action_name</span><span class="p">,</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">safe_pickle</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
            <span class="n">prio</span><span class="p">,</span>
            <span class="n">running</span><span class="p">,</span>
            <span class="n">run_count</span><span class="p">,</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">get_time</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">memid</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">agent</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_task</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">task</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span>
            <span class="s2">&quot;UPDATE Tasks SET run_count=?, pickled=? WHERE uuid=?&quot;</span><span class="p">,</span>
            <span class="n">task</span><span class="o">.</span><span class="n">run_count</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">safe_pickle</span><span class="p">(</span><span class="n">task</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conditions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        conditions is a dict with keys in</span>
<span class="sd">        &quot;init_condition&quot;, &quot;terminate_condition&quot;</span>
<span class="sd">        and values being Condition objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">condition</span> <span class="ow">in</span> <span class="n">conditions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">condition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_task</span><span class="p">()</span>

    <span class="c1"># FIXME names/constants for some specific prios</span>
    <span class="c1"># use this to update prio or running, don&#39;t do it directly on task or in db!!</span>
    <span class="k">def</span> <span class="nf">get_update_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">force_db_update</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">force_task_update</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        status is a dict with possible keys &quot;prio&quot;, &quot;running&quot;, &quot;paused&quot;, &quot;finished&quot;.</span>

<span class="sd">        prio &gt; CHECK_PRIO  :  run me if possible, check my terminate condition</span>
<span class="sd">        prio = CHECK_PRIO  :  check my init_condition, run if true</span>
<span class="sd">        prio &lt; CHECK_PRIO :  don&#39;t even check init_condition, I&#39;m done or unhatched</span>
<span class="sd">        prio = EGG_PRIO :  I&#39;m unhatched</span>

<span class="sd">        running = 1 :  task should be stepped if possible and not explicitly paused</span>
<span class="sd">        running = 0 :  task should not be stepped</span>

<span class="sd">        finished &gt;  0 :  task has run and is complete, completed at the time indicated</span>
<span class="sd">        finished = -1 :  task has not completed</span>

<span class="sd">        paused = 1 : explicitly stopped by some other process; don&#39;t check any condtions and leave me alone</span>
<span class="sd">        paused = 0 : go on as normal</span>

<span class="sd">        this method updates these columns of the DB for each of the keys if have values</span>
<span class="sd">        if force_db_update is set, these will be updated with the relevant attr from self.task</span>
<span class="sd">        even if it is not in the status dict.</span>
<span class="sd">        if force_task_update is set, the information will go the other way,</span>
<span class="sd">        and whatever is in the dict will be put on the task.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">status_out</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;finished&quot;</span><span class="p">,</span> <span class="s2">&quot;prio&quot;</span><span class="p">,</span> <span class="s2">&quot;running&quot;</span><span class="p">,</span> <span class="s2">&quot;paused&quot;</span><span class="p">]:</span>
            <span class="c1"># update the task itself, hopefully don&#39;t need to do this when task objects are re-written as MemoryNode s</span>
            <span class="k">if</span> <span class="n">force_task_update</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">status</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;finished&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
                    <span class="n">status_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span>
                    <span class="c1"># warning: using the order of the iterator!</span>
                    <span class="n">status</span><span class="p">[</span><span class="s2">&quot;running&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">status</span><span class="p">[</span><span class="s2">&quot;prio&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">FINISHED_PRIO</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">status_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">status_out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">status</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="n">status</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">force_db_update</span> <span class="ow">and</span> <span class="n">status_out</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;UPDATE Tasks SET &quot;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s2">&quot;=? WHERE uuid=?&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">db_write</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span> <span class="n">status_out</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status_out</span>

    <span class="c1"># FIXME! or torch me</span>
    <span class="k">def</span> <span class="nf">propagate_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
        <span class="c1"># if the parent of a task is paused, propagate to children</span>
        <span class="c1"># if parent is currently paused and then unpaused, propagate to children</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">add_child_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">prio</span><span class="o">=</span><span class="n">CHECK_PRIO</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add (and by default activate) a child task, and pass along the id</span>
<span class="sd">        of the parent task (current task).  A task can only have one direct</span>
<span class="sd">        descendant any any given time.  To add a list of children use a ControlBlock</span>

<span class="sd">        Args:</span>
<span class="sd">            t: the task to be added.  a *Task* object, not a TaskNode</span>
<span class="sd">               agent: the agent running this task</span>
<span class="sd">            prio: default 1 (CHECK_PRIO + 1), set to 0 (CHECK_PRIO) if you want the child task added but not activated,</span>
<span class="sd">                  None if you want it added but its conditions left in charge</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">TaskMem</span> <span class="o">=</span> <span class="n">TaskNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">memid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prio</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO mark that child task has been forcefully activated if it has non-trivial run_condition?</span>
            <span class="n">TaskMem</span><span class="o">.</span><span class="n">get_update_status</span><span class="p">({</span><span class="s2">&quot;prio&quot;</span><span class="p">:</span> <span class="n">prio</span><span class="p">})</span>
        <span class="n">TripleNode</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">subj</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">memid</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;_has_parent_task&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">)</span>
        <span class="n">TripleNode</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">memid</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;_has_child_task&quot;</span><span class="p">,</span> <span class="n">subj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_chat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ChatNode</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the memory of the chat that caused this task&#39;s creation, or None&quot;&quot;&quot;</span>
        <span class="n">triples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">get_triples</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;chat_effect_&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">triples</span><span class="p">:</span>
            <span class="n">chat_id</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">triples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ChatNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">chat_id</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_parent_task</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;TaskNode&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return the &#39;TaskNode&#39; of the parent task, or None&quot;&quot;&quot;</span>
        <span class="n">triples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">get_triples</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">subj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;_has_parent_task&quot;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">triples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">triples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">parent_memid</span> <span class="o">=</span> <span class="n">triples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">TaskNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">parent_memid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;Task </span><span class="si">{}</span><span class="s2"> has multiple parents: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">memid</span><span class="p">,</span> <span class="n">triples</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_root_task</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;TaskNode&quot;</span><span class="p">]:</span>
        <span class="n">mem</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parent_task</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mem</span> <span class="o">=</span> <span class="n">parent</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">get_parent_task</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mem</span>

    <span class="k">def</span> <span class="nf">get_child_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;TaskNode&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return tasks that were spawned beause of this task&quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">TripleNode</span><span class="o">.</span><span class="n">NODE_TYPE</span><span class="p">]</span><span class="o">.</span><span class="n">get_triples</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">pred_text</span><span class="o">=</span><span class="s2">&quot;_has_parent_task&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">memid</span>
        <span class="p">)</span>
        <span class="n">memids</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">r</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">TaskNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">agent_memory</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">memids</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">all_descendent_tasks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_root</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;TaskNode&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return a list of &#39;TaskNode&#39; objects whose _has_parent_task root is this task</span>
<span class="sd">        If include_root is True, include this node in the list.</span>
<span class="sd">        Tasks are returned in the order they were finished.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">descendents</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">q</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">children</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">get_child_tasks</span><span class="p">()</span>
            <span class="n">descendents</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
            <span class="n">q</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">include_root</span><span class="p">:</span>
            <span class="n">descendents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">descendents</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">finished</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;TaskNode: </span><span class="si">{}</span><span class="s2">&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">task</span><span class="p">)</span></div>


<span class="c1"># list of nodes to register in memory</span>
<span class="n">NODELIST</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">TaskNode</span><span class="p">,</span>
    <span class="n">ChatNode</span><span class="p">,</span>
    <span class="n">LocationNode</span><span class="p">,</span>
    <span class="n">AttentionNode</span><span class="p">,</span>
    <span class="n">TripleNode</span><span class="p">,</span>
    <span class="n">InterpreterNode</span><span class="p">,</span>
    <span class="n">SetNode</span><span class="p">,</span>
    <span class="n">TimeNode</span><span class="p">,</span>
    <span class="n">PlayerNode</span><span class="p">,</span>
    <span class="n">SelfNode</span><span class="p">,</span>
    <span class="n">ProgramNode</span><span class="p">,</span>
    <span class="n">NamedAbstractionNode</span><span class="p">,</span>
    <span class="n">ReferenceObjectNode</span><span class="p">,</span>
<span class="p">]</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Facebook AI.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>